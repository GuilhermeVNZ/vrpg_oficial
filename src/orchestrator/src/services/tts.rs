//! TTS Service Client
//!
//! Client for communicating with the TTS service (localhost:7003)

use crate::error::{OrchestratorError, Result};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tracing::{error, info, warn};

const TTS_SERVICE_URL: &str = "http://localhost:7003";

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TtsRequest {
    pub text: String,
    pub language: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TtsResponse {
    pub audio: Vec<f32>,
    pub sample_rate: u32,
    pub channels: u16,
    pub duration_ms: u64,
    pub actor: String,
    pub emotion: String,
    pub style: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VoiceInfo {
    pub character_id: String,
    pub name: String,
    pub emotions: Vec<String>,
    pub styles: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthResponse {
    pub status: String,
    pub service: String,
    pub version: String,
    pub model_loaded: bool,
    pub voices: Vec<String>,
}

/// TTS Service Client
#[derive(Clone)]
pub struct TtsClient {
    base_url: String,
    client: reqwest::Client,
}

impl TtsClient {
    /// Create a new TTS client
    pub fn new() -> Self {
        Self {
            base_url: TTS_SERVICE_URL.to_string(),
            client: reqwest::Client::new(),
        }
    }

    /// Create with custom URL
    pub fn with_url(url: String) -> Self {
        Self {
            base_url: url,
            client: reqwest::Client::new(),
        }
    }

    /// Check if TTS service is healthy
    pub async fn health_check(&self) -> Result<HealthResponse> {
        let url = format!("{}/health", self.base_url);

        match self.client.get(&url).send().await {
            Ok(response) => {
                if response.status().is_success() {
                    match response.json::<HealthResponse>().await {
                        Ok(health) => {
                            info!(
                                "TTS service health: {} - models loaded: {}",
                                health.status, health.model_loaded
                            );
                            Ok(health)
                        }
                        Err(e) => {
                            error!("Failed to parse TTS health response: {}", e);
                            Err(OrchestratorError::ServiceError(format!(
                                "TTS service parse error: {}",
                                e
                            )))
                        }
                    }
                } else {
                    warn!("TTS service health check failed: {}", response.status());
                    Err(OrchestratorError::ServiceError(format!(
                        "TTS service unhealthy: {}",
                        response.status()
                    )))
                }
            }
            Err(e) => {
                error!("TTS service connection error: {}", e);
                Err(OrchestratorError::ServiceError(format!(
                    "TTS service connection error: {}",
                    e
                )))
            }
        }
    }

    /// Synthesize speech from text (with Voice INTENT tags)
    ///
    /// The text may contain `<VOICE>` tags generated by the LLM.
    /// The TTS service will parse these tags and apply appropriate voice conversion.
    pub async fn speak(&self, text: &str, language: Option<&str>) -> Result<TtsResponse> {
        let url = format!("{}/speak", self.base_url);

        let request = TtsRequest {
            text: text.to_string(),
            language: language.map(|s| s.to_string()),
        };

        match self.client.post(&url).json(&request).send().await {
            Ok(response) => {
                if response.status().is_success() {
                    match response.json::<TtsResponse>().await {
                        Ok(tts_response) => {
                            info!(
                                "TTS synthesis complete: {}ms, actor={}, emotion={}",
                                tts_response.duration_ms, tts_response.actor, tts_response.emotion
                            );
                            Ok(tts_response)
                        }
                        Err(e) => {
                            error!("Failed to parse TTS response: {}", e);
                            Err(OrchestratorError::ServiceError(format!(
                                "TTS parse error: {}",
                                e
                            )))
                        }
                    }
                } else {
                    let status = response.status();
                    let error_text = response
                        .text()
                        .await
                        .unwrap_or_else(|_| "Unknown error".to_string());
                    error!("TTS synthesis failed: {} - {}", status, error_text);
                    Err(OrchestratorError::ServiceError(format!(
                        "TTS synthesis failed: {} - {}",
                        status, error_text
                    )))
                }
            }
            Err(e) => {
                error!("TTS service connection error: {}", e);
                Err(OrchestratorError::ServiceError(format!(
                    "TTS connection error: {}",
                    e
                )))
            }
        }
    }

    /// List available voices
    pub async fn list_voices(&self) -> Result<Vec<VoiceInfo>> {
        let url = format!("{}/voices", self.base_url);

        match self.client.get(&url).send().await {
            Ok(response) => {
                if response.status().is_success() {
                    match response.json::<Vec<VoiceInfo>>().await {
                        Ok(voices) => {
                            info!("Found {} voices in TTS service", voices.len());
                            Ok(voices)
                        }
                        Err(e) => {
                            error!("Failed to parse voices response: {}", e);
                            Err(OrchestratorError::ServiceError(format!(
                                "TTS voices parse error: {}",
                                e
                            )))
                        }
                    }
                } else {
                    warn!("TTS voices list failed: {}", response.status());
                    Err(OrchestratorError::ServiceError(format!(
                        "TTS voices list failed: {}",
                        response.status()
                    )))
                }
            }
            Err(e) => {
                error!("TTS service connection error: {}", e);
                Err(OrchestratorError::ServiceError(format!(
                    "TTS connection error: {}",
                    e
                )))
            }
        }
    }

    /// Get metrics from TTS service
    pub async fn get_metrics(&self) -> Result<serde_json::Value> {
        let url = format!("{}/metrics", self.base_url);

        match self.client.get(&url).send().await {
            Ok(response) => {
                if response.status().is_success() {
                    match response.json::<serde_json::Value>().await {
                        Ok(metrics) => Ok(metrics),
                        Err(e) => {
                            error!("Failed to parse metrics response: {}", e);
                            Err(OrchestratorError::ServiceError(format!(
                                "TTS metrics parse error: {}",
                                e
                            )))
                        }
                    }
                } else {
                    warn!("TTS metrics failed: {}", response.status());
                    Err(OrchestratorError::ServiceError(format!(
                        "TTS metrics failed: {}",
                        response.status()
                    )))
                }
            }
            Err(e) => {
                error!("TTS service connection error: {}", e);
                Err(OrchestratorError::ServiceError(format!(
                    "TTS connection error: {}",
                    e
                )))
            }
        }
    }
}

impl Default for TtsClient {
    fn default() -> Self {
        Self::new()
    }
}

pub type SharedTtsClient = Arc<TtsClient>;

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    #[ignore] // Requires TTS service running
    async fn test_tts_client_health() {
        let client = TtsClient::new();
        let result = client.health_check().await;
        // This will fail if TTS service is not running, which is expected
        assert!(result.is_ok() || result.is_err());
    }

    #[tokio::test]
    #[ignore] // Requires TTS service running
    async fn test_tts_client_speak() {
        let client = TtsClient::new();
        let result = client.speak("Hello, world!", Some("en")).await;
        // This will fail if TTS service is not running, which is expected
        assert!(result.is_ok() || result.is_err());
    }
}
